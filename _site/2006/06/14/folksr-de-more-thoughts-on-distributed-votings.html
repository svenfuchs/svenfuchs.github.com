<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <meta name="geo.region" content="DE-BE" />
    <meta name="geo.placename" content="Berlin" />
    <meta name="geo.position" content="52.51168;13.458236" />
    <meta name="ICBM" content="52.51168, 13.458236" />
    <link rel="alternate" type="application/rss+xml" title="RSS" href="http://feeds.feedburner.com/svenfuchs" />
    <link rel="openid.server" href="http://www.myopenid.com/server" />
    <link rel="openid.delegate" href="http://svenfuchs.myopenid.com/" />
    <link href="http://svenfuchs.com" rel="home" />
    <title>folksr.de - more thoughts on distributed votings</title>
    <link rel="stylesheet" href="/stylesheets/styles.css">
    <link rel="stylesheet" href="/stylesheets/highlight.css">
    <script src="/javascripts/highlight.js"></script>
  </head>
  <body>
    <div id="page">
  <div id="content">
    <p><a href="/">&larr; Home</a></p>

    <div id="post">
      <h1>folksr.de - more thoughts on distributed votings</h1>
      <h2>1. Add a form to get the votes from a certain url in and immediately see
the results.</h2>

<p>I believe there should be at least one way to get the own votes in by
<em>doing</em> something in a classical or familiar way. Publish something
on your homepage, go  somewhere else, annouce it. That's a process
everybody knows and understands. It's probably some kind of
root-experience with the internet. :) And even if that's to pathetical
than it's at least a fallback mode that will reliably work when the other
stuff fails.</p>

<h2>2. Add some kind of ID to the votes to identify a vote as <em>the
same</em> vote like another</h2>

<p>As soon as any application adds any kind of sh*t ... sorry, parameter
to the URL the vote will be counted more than once - be it something
unRESTy like a SessionID or even my shiny Typo blogging engines URL
layout: It will smash the whole purpose of publishing <strong>one</strong>
vote-for link in one single go.</p>

<p>To stick with the example of my blog: as soon as I don't put the
vote-for link in the "extended" content it will appear on the blog start
page, on the articles details page, and various archive, categories ...
etc. pages.  I think something very similar will apply to practically
every blogging engine out there, won't it?</p>

<p>I yet wonder if using <a href="http://microid.org">MicroID</a> would be
applicable here or if there's something even simpler.</p>

<p>A MicroID is defined as: </p>
<pre>
MicroID = sha1_hex(sha1_hex("mailto:user@email.com") +
  sha1_hex("http://website.com"));
</pre>
<p>which would result in a hash like:
<code>2067da21d6a17c4264c432a0d26535b09cbd6a2f</code> and could be used
as in:</p>
<pre>
&lt;a class="microid-a9993e364706816aba3e25717850c26c9cd0d89d"
  rev="vote-for">&lt;/a>
</pre>

<p>But of course the MicroID seems to be a bit more than what would be
necessary at the <strong>very</strong> least: that would be any unique ID
that's used with a vote-for link. The voting system would simply refuse to
count a link with an ID that's already in the database. Or it (better yet)
would remove the present vote.</p>

<p>This minimum of a unique ID would say: "To make sure that this (one) vote
won't be counted more than once (even if it occures on different URLs) include
this unique ID." No more. This would be the minimum.</p>

<p>The MicroID would furthermore include personal/social identity like in:
"This (link) is the vote-for (option) X like placed by (person) A."</p>


<h2>3. Check out the idea to parse the webservers referrer logs ...</h2>

<p>... or simply check for the presence of a HTTP Referer at <em>any
request</em> and get rid of the webbug stuff if that works.</p>

<p>Heck. Today I wonder why this hasn't occured to me before! :) But it was <a
href="http://suda.co.uk/">Brian Suda</a> who suggested on the microformats mailinglist:</p>

<p><em>"You could just use your referrer log to find inbound
links and then spider just those. The downside is that peole without
traffic would not get their vote in, so the blogger themself would
have to click the link to "activate" the vote. It is sort if the same
effect as your 'webbug' idea without the hassel."</em> Obviously. Thanks,
Brian! :)</p>

<p>I yet have to think about pros/contras for either observing the logs or
spider a page as a reaction on clicks only. Either way the application
would require the user to activate the vote by clicking it AND would
require him to use a browser that sends a valid HTTP referer string.</p>
<p>But both downsides are not really different from what the webbug would
do - just simpler in that they both avoid a separate pixel/image.</p>


    </div>

    <div id="disqus_thread"></div>
    <script type="text/javascript">
        var disqus_shortname = 'svenfuchs';
        var disqus_title = '<%= page.title %>';
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

  </div>
</div>

    <a href="http://svenfuchs.com" rel="me" ></a>
    <script type="text/javascript">
      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-24665870-1']);
      _gaq.push(['_trackPageview']);
      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();
    </script>
  </body>
</html>
